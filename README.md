# Movie Reservation System (MRS)

## 目录
1.  [项目概述](#项目概述)
2.  [核心功能](#核心功能)
    *   [用户认证与授权](#用户认证与授权)
    *   [电影管理 (管理员)](#电影管理-管理员)
    *   [预订管理](#预订管理)
    *   [报告功能 (管理员)](#报告功能-管理员)
3.  [技术栈 (初步设想)](#技术栈-初步设想)
4.  [数据模型 (初步设想)](#数据模型-初步设想)
5.  [API 端点设计 (初步设想)](#api-端点设计-初步设想)
6.  [关键设计考量与高并发应对](#关键设计考量与高并发应对)
    *   [高并发场景识别](#高并发场景识别)
    *   [缓存层设计 (Redis)](#缓存层设计-redis)
    *   [数据一致性与并发控制](#数据一致性与并发控制)
    *   [座位管理策略](#座位管理策略)
    *   [异步处理与消息队列 (可选)](#异步处理与消息队列-可选)
    *   [其他](#其他)
7.  [项目搭建与运行 (占位符)](#项目搭建与运行-占位符)
    *   [环境要求](#环境要求)
    *   [安装步骤](#安装步骤)
    *   [运行应用](#运行应用)
    *   [运行测试](#运行测试)
8.  [后续步骤与未来增强](#后续步骤与未来增强)
9.  [贡献指南 (占位符)](#贡献指南-占位符)

## 1. 项目概述

Movie Reservation System (MRS) 是一个后端服务，旨在提供一个完整的电影票在线预订解决方案。用户可以注册账户、登录、浏览电影信息、查询特定日期的放映场次、选择座位并完成预订。系统还包含管理员功能，用于管理电影、放映时间以及查看系统运营数据。

**本项目在原有基础上，重点关注系统在高并发场景下的性能和稳定性，并引入缓存层作为关键优化手段。**

本项目的主要目标是：
*   实现复杂的业务逻辑，特别是座位预订与调度，**并确保其在高并发下的正确性和效率**。
*   深入理解数据模型设计及其关系。
*   构建健壮的用户认证和授权机制。
*   实践复杂查询和数据报告的生成。
*   **设计并实现有效的缓存策略，以提升系统响应速度并降低数据库压力。**

## 2. 核心功能

### 用户认证与授权
*   **用户注册**：新用户可以创建账户。
*   **用户登录**：已注册用户可以登录系统。
*   **角色管理**：
    *   **普通用户 (User)**：可以浏览电影、预订场次、查看和取消自己的预订。
    *   **管理员 (Admin)**：拥有普通用户的所有权限，并能管理电影、放映时间、查看所有预订和系统报告。
*   **初始管理员**：系统将通过种子数据（Seed Data）创建初始管理员账户。
*   **权限提升**：只有管理员可以将其他普通用户提升为管理员。

### 电影管理 (管理员)
*   **添加电影**：管理员可以添加新的电影信息。
    *   属性：标题 (Title)、描述 (Description)、海报图片 (Poster Image URL)。
*   **更新电影**：管理员可以修改已存在的电影信息。
*   **删除电影**：管理员可以删除电影。
*   **电影分类**：电影应按类型 (Genre) 进行分类（例如：动作、喜剧、科幻）。
*   **放映时间管理**：
    *   管理员可以为电影安排放映时间 (Showtimes)。
    *   每个放映时间关联到特定的电影、影厅和时间。

### 预订管理
*   **浏览电影与场次**：用户可以获取特定日期的电影列表及其可用的放映时间。**此功能将重点利用缓存提升查询效率。**
*   **座位预订**：
    *   用户可以查看特定放映时间的座位图 (Seat Map) 及可用座位。**座位状态的快速查询和更新是高并发挑战的核心。**
    *   用户可以选择一个或多个座位进行预订。
    *   系统需防止超额预订，**尤其是在大量用户同时抢票的场景**。
*   **查看我的预订**：用户可以查看自己所有已预订的电影票。
*   **取消预订**：用户可以取消尚未开始的预订。

### 报告功能 (管理员)
*   **查看所有预订**：管理员可以查看系统中所有的预订记录。
*   **上座率/容量报告**：管理员可以查看各场次的上座率和影院容量使用情况。
*   **收入报告**：管理员可以查看基于预订产生的收入情况。

## 3. 技术栈 (初步设想)

*   **编程语言**: **Go (Golang)**
*   **Web 框架 (可选但推荐)**: Gin
*   **数据库**: 关系型数据库 MySql (或其他如 PostgreSQL)
*   **数据库驱动/ORM**: GORM (或 sqlx/database/sql)
*   **缓存**: **Redis** (用于数据缓存、分布式锁、会话管理等)
*   **认证机制**: JWT (JSON Web Tokens)
*   **API 类型**: RESTful API
*   **容器化**: Docker
*   **(可选) 消息队列**: [待定 - 例如：Kafka, RabbitMQ, NATS - 用于异步任务处理、削峰填谷]
*   **(可选) 配置管理**: [待定 - 例如：Viper, godotenv]
*   **(可选) 日志库**: [待定 - 例如：Zap, Logrus]
*   **(可选) 服务发现/注册**: [待定 - 例如：Consul, etcd - 若未来考虑微服务架构]

选择具体技术栈时，将优先考虑开发效率、社区支持、性能、可扩展性以及团队熟悉度。

## 4. 数据模型 (初步设想)

以下是核心实体及其关系的基本构想：

*   `User (id, username, password_hash, email, role_id)`
*   `Role (id, name)` (e.g., 'ADMIN', 'USER')
*   `Movie (id, title, description, poster_image_url, duration_minutes)`
*   `Genre (id, name)`
*   `MovieGenre (movie_id, genre_id)` (多对多关系)
*   `CinemaHall (id, name, total_seats)` (影厅)
*   `Showtime (id, movie_id, hall_id, start_time, end_time, price_per_seat)`
*   `Seat (id, hall_id, row_identifier, seat_number, type)` (物理座位，可用于复杂座位图)
*   `Booking (id, user_id, showtime_id, booking_time, total_amount, status)` (e.g., 'CONFIRMED', 'CANCELLED', 'PENDING')
*   `BookedSeat (id, booking_id, showtime_id, seat_id)` (或者 `row_identifier`, `seat_number` 如果座位不是全局唯一ID)

此数据模型会随着开发的深入进行迭代和优化。**考虑哪些数据适合被缓存，例如 `Movie` 详情、`Showtime` 列表等。**

## 5. API 端点设计 (初步设想)

以下是一些关键的 API 端点（路径和方法可能会调整）：

**认证 (Auth)**
*   `POST /api/auth/register` - 用户注册
*   `POST /api/auth/login` - 用户登录 (登录成功后 Session/Token 可存入 Redis)
*   `POST /api/auth/logout` - 用户登出

**用户 (Users)**
*   `GET /api/users/me` - 获取当前用户信息 (可缓存用户信息)
*   `PUT /api/admin/users/{userId}/promote` - (Admin) 提升用户为管理员

**电影 (Movies)**
*   `GET /api/movies` - 获取所有电影列表 (可带分页、筛选、排序参数) **[缓存重点]**
*   `GET /api/movies/{movieId}` - 获取特定电影详情 **[缓存重点]**
*   `POST /api/admin/movies` - (Admin) 添加新电影 (注意缓存更新/失效)
*   `PUT /api/admin/movies/{movieId}` - (Admin) 更新电影信息 (注意缓存更新/失效)
*   `DELETE /api/admin/movies/{movieId}` - (Admin) 删除电影 (注意缓存更新/失效)
*   `GET /api/genres` - 获取所有电影类型 **[缓存重点]**

**放映时间 (Showtimes)**
*   `GET /api/showtimes?date={YYYY-MM-DD}[&movieId={id}]` - 获取特定日期（可选电影）的放映时间 **[缓存重点]**
*   `GET /api/showtimes/{showtimeId}/seats` - 获取特定场次的座位图及可用状态 **[缓存重点，但需注意实时性与一致性]**
*   `POST /api/admin/movies/{movieId}/showtimes` - (Admin) 为电影添加放映时间 (注意缓存更新/失效)
*   `PUT /api/admin/showtimes/{showtimeId}` - (Admin) 更新放映时间 (注意缓存更新/失效)
*   `DELETE /api/admin/showtimes/{showtimeId}` - (Admin) 删除放映时间 (注意缓存更新/失效)

**预订 (Bookings)**
*   `POST /api/bookings` - 用户创建新预订 (请求体包含 `showtimeId`, `seatIds`) **[高并发核心接口，需重点设计锁机制和防超卖]**
*   `GET /api/bookings/me` - 用户查看自己的预订列表
*   `GET /api/bookings/{bookingId}` - 用户查看特定预订详情
*   `PATCH /api/bookings/{bookingId}/cancel` - 用户取消预订 (仅限未开始的)
*   `GET /api/admin/bookings` - (Admin) 查看所有用户预订 (可带分页、筛选参数)

**报告 (Reports) (Admin)**
*   `GET /api/admin/reports/revenue?startDate={date}&endDate={date}` - 获取指定时间范围内的收入报告
*   `GET /api/admin/reports/occupancy?showtimeId={id}` - 获取特定场次的上座率
*   `GET /api/admin/reports/movie-performance` - 获取电影表现报告

## 6. 关键设计考量与高并发应对

### 高并发场景识别
系统需要在以下场景下保持高性能和数据一致性：
*   **热门电影开售/查询**：大量用户同时浏览电影、查询场次。
*   **座位预订**：多个用户同时抢购同一场次的特定座位（类似秒杀场景）。
*   **读取密集型操作**：如获取电影列表、详情、场次信息等。

### 缓存层设计 (Redis)
引入 Redis 作为缓存层，主要目的：
*   **提升读取性能**：显著减少对数据库的直接访问，加快响应速度。
*   **降低数据库负载**：保护数据库免受高并发读取的冲击。

**缓存数据范围**：
*   **静态/准静态数据**：电影信息（详情、列表、分类）、影厅布局等。缓存更新频率低。
*   **热点动态数据**：
    *   特定日期和电影的放映时间列表。
    *   场次座位图及可用状态（需要精心设计缓存更新与失效策略，平衡实时性与性能）。
*   **用户会话数据**：存储 JWT token 的黑名单（用于登出）或用户会话信息。

**缓存策略思考**：
*   **缓存读取模式**：主要采用 **Cache-Aside (旁路缓存)** 模式。应用先从 Redis 读取，若未命中，则从数据库加载，然后写入 Redis。这对于有 C++ 背景的你来说，可以理解为程序自己管理一个外部的高速查找表。
*   **缓存写入与更新**：
    *   数据发生变更（如管理员修改电影信息）时，需要有策略更新或使缓存失效（例如，删除相关缓存键，让下次读取时重新加载）。
    *   对于座位这种高频变动数据，可能需要更精细的控制或较短的缓存过期时间。
*   **缓存过期策略**：为缓存数据设置合理的生存时间 (TTL)，防止过期数据。通过添加随机扰动避免缓存雪崩。
*   **应对缓存常见问题**：
    *   **缓存穿透**（查询不存在的数据）：对空结果也进行缓存（短时间），或使用布隆过滤器。
    *   **缓存击穿**（热点 Key 失效）：使用分布式锁（如基于 Redis 的 `SETNX`）保护数据库查询和缓存回填过程，只允许一个请求去加载数据。
    *   **缓存雪崩**（大量 Key 同时失效或 Redis 宕机）：设置不同的过期时间、Redis 集群部署实现高可用。
*   **缓存键设计**：清晰、一致的缓存键命名规范，例如 `movie:{movieId}`, `showtimes:date:{YYYY-MM-DD}:movie:{movieId}`。

### 数据一致性与并发控制
座位预订是核心，必须确保在高并发场景下不超额预订。
*   **乐观锁与悲观锁**：
    *   **数据库层面**：可以使用 `SELECT ... FOR UPDATE` (悲观锁) 或在更新时检查版本号 (乐观锁) 来保证事务的原子性和隔离性。
    *   **应用/缓存层面**：
        *   **Redis 分布式锁**：在用户选择座位到确认预订的关键路径上，使用 Redis 实现分布式锁 (例如 `SET key value NX PX milliseconds`) 来控制对特定座位或场次的并发访问。这类似于 C++ 中的 `std::mutex` 或 `std::atomic_flag`，但作用范围是跨多个服务实例的。
        *   **原子操作**：利用 Redis 的原子操作（如 `INCRBY`, `DECRBY`）管理可用座位数（预扣减库存），或者使用 Lua 脚本保证多个 Redis 命令的原子性。
*   **事务管理**：数据库操作（如创建订单、更新座位状态）应包裹在数据库事务中。
*   **幂等性设计**：对于创建预订等操作，需要考虑接口的幂等性，防止因重试导致重复下单。

### 座位管理策略
*   **座位状态表示**：
    *   可以在 Redis 中使用 Set 或 Hash 存储某一场次已预订或锁定的座位ID。例如：`SADD showtime:{showtimeId}:booked_seats seat_A1 seat_B2`。
    *   或者使用 Bitmap 来表示整个影厅的座位状态，每个位代表一个座位，非常节省空间，并能利用位操作快速判断。
*   **预订流程**：
    1.  用户查询座位图（可从缓存获取）。
    2.  用户选择座位，请求预订。
    3.  后端尝试锁定座位（例如，通过 Redis 分布式锁或原子操作标记座位）。
    4.  锁定成功，则继续创建数据库订单，更新数据库中的座位状态。
    5.  锁定失败，则告知用户座位已被占用。
    6.  （可选）引入“预留”状态：用户选择座位后，短时间锁定，超时未支付则释放。这需要 Redis 的过期键功能。

### 异步处理与消息队列 (可选但推荐在高并发系统中考虑)
对于一些非核心但耗时的操作，可以引入消息队列（如 Kafka, RabbitMQ, NATS）进行异步处理，提升主流程的响应速度和系统吞吐量。
*   **场景**：
    *   预订成功后发送确认邮件/短信。
    *   生成复杂的报表数据。
    *   同步数据到其他系统。
*   **好处**：削峰填谷，提高系统韧性。请求先快速响应用户，后台任务慢慢处理。这和 C++ 中你可能会用一个线程池来处理后台任务类似，但消息队列提供了更强的解耦和可靠性。

### 其他
*   **放映时间调度**：如何设计调度逻辑，避免同一影厅在同一时间段安排多个场次（数据库约束或应用层检查）。
*   **认证与授权**：选择合适的认证方案 (如 JWT)，并实现精细的基于角色的授权控制。JWT token 可以存储在客户端，服务端通过校验签名来验证。
*   **可扩展性**：系统设计应考虑到未来可能的扩展，如引入支付网关、更复杂的座位类型和价格策略等。
*   **错误处理与日志记录**：健壮的错误处理机制和全面的日志记录对于问题排查和系统监控至关重要。Go 语言的 `error` 处理方式与 C++ 的异常机制不同，需要适应。
*   **API 限流**：为防止恶意请求或突发流量冲垮系统，可以对关键 API（如预订接口）实施限流策略（例如基于 Redis 的令牌桶或漏桶算法）。

## 7. 项目搭建与运行 (占位符)

本部分将在项目初始化后填充具体的指令。

### 环境要求
*   Go (例如：1.18 或更高版本)
*   MySql (例如：8.0) / PostgreSQL (例如：13)
*   Redis (例如：6.x 或更高版本)
*   Docker (推荐)

### 安装步骤
```bash
# 1. 克隆仓库
git clone [repository-url]
cd movie-reservation-system

# 2. 配置环境变量
# cp .env.example .env
# (编辑 .env 文件配置数据库连接、Redis连接、JWT密钥等)

# 3. (如果使用 Docker Compose)
# docker-compose up --build -d

# 4. (如果手动运行)
# go mod tidy
# go build -o mrs_server ./cmd/server/
# (数据库迁移指令，取决于使用的ORM或迁移工具)
```

### 运行应用
```bash
# (如果使用 Docker Compose)
# docker-compose logs -f mrs_app

# (如果手动运行)
# ./mrs_server
```

### 运行测试
```bash
# go test ./...
```

## 8. 后续步骤与未来增强
*   实现完整的支付集成。
*   添加邮件/短信通知功能。
*   开发更详细的后台管理界面。
*   引入更精细化的缓存策略和监控。
*   **压力测试和性能调优，特别关注高并发场景下的瓶颈点。**
*   **探索服务拆分，向微服务架构演进的可能性。**
*   实现基于 Redis 的更高级功能，如排行榜、最近浏览等。

## 9. 贡献指南 (占位符)
(待定)

---

这个修改后的版本应该能更好地反映你对高并发和缓存的需求。记住，这只是一个初步的规划，在实际开发过程中，很多细节还需要进一步推敲和迭代。特别是缓存策略和并发控制，是需要根据具体场景反复测试和优化的。

你在 C++ 中处理多线程和锁的经验，对于理解 Go 的 goroutine、channel 以及这里提到的分布式锁会有帮助。Go 的并发模型更轻量，通过 channel 进行通信通常比共享内存加锁（C++ 中常见）更安全、更不容易出错，但对于需要跨进程/服务实例的互斥访问，像 Redis 这样的外部组件就非常重要了。

希望这个对你有帮助！如果你有其他问题或想深入讨论某个点，随时告诉我。